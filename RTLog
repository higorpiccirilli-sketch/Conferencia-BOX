<!--
  RTLog.html – Log em Tempo Real (Only-Text Edition)
  Template vars injetadas pelo servidor:
    <?= title ?>            – título exibido no cabeçalho
    <?= execId ?>           – id da execução (cache key)
    <?= serverFunction ?>   – função GAS a ser chamada no início (ex.: MB2_atualizarTodos_comLog)
-->
<!DOCTYPE html>
<html>
<head>
  <base target="_top">
  <meta charset="utf-8" />
  <style>
    :root{
      --bg: #282C34;         /* Fundo (modal/rodapé)   */
      --text: #ABB2BF;       /* Texto base             */
      --border: #333333;     /* Borda/divisores        */
      --ts: #5C6370;         /* Timestamp              */
      --info: #61AFEF;       /* [INICIANDO]/[EM ANDAMENTO] */
      --ok: #98C379;         /* [OK] / ✅              */
      --warn: #E5C07B;       /* [AVISO]                */
      --err: #E06C75;        /* [ERRO]/[ERRO FATAL]    */
      --final: #C678DD;      /* Mensagem Final         */
    }
    html, body { height: 100%; }
    body{
      margin:0; background:var(--bg); color:var(--text);
      font-family: "Roboto Mono", ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      font-size:14px; line-height:1.45;
    }
    .wrap{ height:100%; display:flex; flex-direction:column; padding:20px; box-sizing:border-box; }
    .head{ display:flex; align-items:center; justify-content:space-between; margin-bottom:12px; }
    .title{ font-family: Inter, Roboto, system-ui, -apple-system, Segoe UI, Arial; font-weight:700; font-size:18px; letter-spacing:.3px; }
    .spinner{ width:16px; height:16px; border:2px solid var(--ts); border-top-color: var(--info); border-radius:50%; animation: spin 1s linear infinite; margin-left:8px; }
    @keyframes spin { to { transform: rotate(360deg); } }

    .toolbar{ display:flex; gap:8px; align-items:center; margin-bottom:12px; }
    button{
      border:1px solid var(--border); background:transparent; color:var(--text);
      padding:8px 10px; border-radius:8px; cursor:pointer; font-family: Inter, Roboto, system-ui, -apple-system, Segoe UI, Arial; font-size:13px;
    }
    button:hover{ background:rgba(255,255,255,0.04); }
    button:disabled{ opacity:.6; cursor:not-allowed; }

    .log{
      position:relative; flex:1 1 auto; border:1px solid var(--border);
      border-radius:10px; overflow:auto; padding:10px; background:rgba(0,0,0,0.08);
    }
    .line{ display:grid; grid-template-columns: 170px 1fr; gap:10px; padding:6px 8px; border-bottom:1px solid #2e3138; white-space: pre-wrap; word-wrap: break-word; }
    .line:last-child{ border-bottom:0; }
    .ts{ color:var(--ts); }
    .txt{ color:var(--text); }
    .status-andamento .txt { color: var(--info); font-weight:600; }
    .status-ok       .txt { color: var(--ok); font-weight:600; }
    .status-aviso    .txt { color: var(--warn); font-weight:600; }
    .status-erro     .txt { color: var(--err); font-weight:700; }
    .status-final    .txt { color: var(--final); font-weight:700; }
    .foot{ margin-top:10px; display:flex; justify-content:space-between; color:#8b92a0; font-size:12px; }
    .kbd{ padding:1px 4px; border:1px solid var(--border); border-radius:4px; background:#1f232a; color:#c0c6d4; }
  </style>
</head>
<body>
  <div class="wrap" role="application">
    <div class="head">
      <div class="title" aria-live="polite">
        <?= title ?>
        <span id="spinner" class="spinner" aria-hidden="true"></span>
      </div>
      <div id="counter" aria-live="polite">0 linhas</div>
    </div>

    <div class="toolbar">
      <button id="btnExport"  title="Exportar TXT (UTF-8)" onclick="exportTxt()">Exportar</button>
      <button id="btnCopy"    title="Copiar tudo" onclick="copyAll()">Copiar tudo</button>
      <button id="btnPause"   title="Pausar/Retomar rolagem automática" onclick="toggleScroll()">Pausar rolagem</button>
      <button id="btnClear"   title="Limpar visual (não apaga servidor)" onclick="clearVisual()">Limpar</button>
      <span style="flex:1"></span>
      <button id="btnClose"   title="Fechar (Esc)" onclick="google.script.host.close()">Fechar</button>
    </div>

    <div id="log" class="log" role="log" aria-live="polite" aria-relevant="additions"></div>

    <div class="foot">
      <div>Atalhos: <span class="kbd">Esc</span> fecha • <span class="kbd">Ctrl/Cmd + C</span> copia seleção</div>
      <div id="status"></div>
    </div>
  </div>

  <script>
    const execId   = '<?= execId ?>';
    const serverFn = '<?= serverFunction ?>';

    // Especificação: polling = 1500ms; deduplicação; auto-scroll on por padrão; backoff até 3x
    let intervalMs   = 1500;
    let failCount    = 0;
    let lastRendered = null;
    let autoScroll   = true;
    let running      = true; // spinner visível até detectar linha final

    const el = id => document.getElementById(id);
    const logBox = el('log');

    function classFromText(t) {
      t = (t || '').toUpperCase();
      if (t.includes('[ERRO FATAL]'))  return 'status-erro';
      if (t.includes('[ERRO]'))        return 'status-erro';
      if (t.includes('[AVISO]') || t.includes('⚠️')) return 'status-aviso';
      if (t.includes('[INICIANDO]') || t.includes('[EM ANDAMENTO]')) return 'status-andamento';
      if (t.includes('✅') || t.includes('[OK]')) return 'status-ok';
      if (t.includes('CONCLUÍDO') || t.includes('FINAL')) return 'status-final';
      return '';
    }

    function appendLine(line){
      if (!line) return;
      // Deduplicação por conteúdo textual
      const textKey = line.ts + '|' + line.text;
      if (lastRendered === textKey) return;
      lastRendered = textKey;

      const row = document.createElement('div');
      row.className = 'line ' + classFromText(line.text);

      const ts = document.createElement('div');
      ts.className = 'ts';
      ts.textContent = line.ts;

      const txt = document.createElement('div');
      txt.className = 'txt';
      txt.textContent = line.text;

      row.appendChild(ts);
      row.appendChild(txt);

      logBox.appendChild(row);
      el('counter').textContent = logBox.children.length + ' linhas';

      if (autoScroll) logBox.scrollTop = logBox.scrollHeight;

      // Controle de spinner: se for final, paramos de mostrar
      if (row.classList.contains('status-final') || row.classList.contains('status-ok')) {
        // se incluir "✅ Concluído", consideramos encerrado
        if ((line.text || '').includes('✅')) {
          running = false;
          el('spinner').style.display = 'none';
        }
      }
    }

    function tick(){
      google.script.run.withSuccessHandler(({line, count}) => {
        failCount = 0;
        if (line) appendLine(line);
        scheduleNext();
      }).withFailureHandler(err => {
        failCount++;
        if (failCount >= 3) {
          appendLine({ts: stampNow(), text: '[ERRO FATAL] Falha repetida ao buscar log: ' + (err && err.message ? err.message : err)});
        }
        scheduleNext(true);
      }).RT_fetchLast(execId);
    }

    function scheduleNext(backoff){
      const ms = backoff ? Math.min(6000, intervalMs * Math.max(2, failCount)) : intervalMs;
      setTimeout(tick, ms);
    }

    function stampNow(){
      // Apenas para mensagens locais de erro; formatação dd/MM/yyyy HH:mm:ss
      const pad = n => String(n).padStart(2,'0');
      const d = new Date();
      const dd = pad(d.getDate());
      const mm = pad(d.getMonth()+1);
      const yyyy = d.getFullYear();
      const hh = pad(d.getHours());
      const mi = pad(d.getMinutes());
      const ss = pad(d.getSeconds());
      return `${dd}/${mm}/${yyyy} ${hh}:${mi}:${ss}`;
    }

    function clearVisual(){
      logBox.innerHTML = '';
      el('counter').textContent = '0 linhas';
      lastRendered = null;
    }

    function toggleScroll(){
      autoScroll = !autoScroll;
      el('btnPause').textContent = autoScroll ? 'Pausar rolagem' : 'Retomar rolagem';
    }

    function copyAll(){
      const txt = Array.from(logBox.querySelectorAll('.line .txt')).map(n => n.textContent).join('\n');
      navigator.clipboard.writeText(txt).then(() => setStatus('Copiado!'));
    }

    function exportTxt(){
      // Pede TODAS as linhas ao servidor e baixa .txt UTF-8
      el('btnExport').disabled = true;
      google.script.run.withSuccessHandler(({lines}) => {
        const content = (lines || []).map(l => `${l.ts}  ${l.text}`).join('\n');
        const blob = new Blob([content], {type: 'text/plain;charset=utf-8'});
        const a = document.createElement('a');
        const now = new Date();
        const name = `log_${(execId||'exec')}_${now.toISOString().slice(0,10)}.txt`;
        a.href = URL.createObjectURL(blob);
        a.download = name;
        document.body.appendChild(a);
        a.click();
        URL.revokeObjectURL(a.href);
        a.remove();
        el('btnExport').disabled = false;
        setStatus('Exportado.');
      }).withFailureHandler(err => {
        el('btnExport').disabled = false;
        appendLine({ts: stampNow(), text: '[ERRO] Não foi possível exportar: ' + (err && err.message ? err.message : err)});
      }).RT_fetchAll(execId);
    }

    function setStatus(msg){
      el('status').textContent = msg || '';
      if (msg) setTimeout(()=>{ el('status').textContent=''; }, 1500);
    }

    // Atalhos de acessibilidade
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') google.script.host.close();
    });

    // Inicialização: chama serverFn automaticamente ao abrir, conforme especificação
    (function init(){
      // começa polling antes mesmo de chamar o server, pois já empurramos [INICIANDO] do lado servidor
      setTimeout(tick, 10);

      if (serverFn) {
        // dispara o processo principal
        google.script.run.withSuccessHandler(() => {
          // nada, execução seguirá escrevendo no log
        }).withFailureHandler(err => {
          appendLine({ts: stampNow(), text: '[ERRO FATAL] Falha ao iniciar processo: ' + (err && err.message ? err.message : err)});
        })[serverFn](execId);
      }
    })();
  </script>
</body>
</html>
