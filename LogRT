/**
 * ===================================================================================
 * LogRT – Logger em tempo real (Only-Text Edition)
 * Arquivo: LogRT.gs
 * -----------------------------------------------------------------------------------
 * Cache por usuário (UserCache): chave lanc_status_<execId>, TTL 6h
 * Buffer: até 1000 linhas (ring buffer)
 * API pública (lado servidor):
 *   RT.push(execId, text, level?)
 *   RT.fetchLast(execId)   → { line: {ts, level, text}, count: <int> } | {line:null,count:0}
 *   RT.fetchAll(execId)    → { lines: [{ts, level, text}], count }
 *   RT.clear(execId)
 * Wrappers: iniciando, andamento, ok, aviso, erro, erroFatal, final
 * ===================================================================================
 */

var RT = (function(){
  var KEY_PREFIX   = 'lanc_status_';    // <== especificação
  var TTL_SECONDS  = 21600;             // 6h
  var MAX_LINES    = 1000;
  var TZ           = 'America/Sao_Paulo';
  var TS_FMT       = "dd/MM/yyyy HH:mm:ss";

  function _key(execId){ return KEY_PREFIX + String(execId || 'default'); }

  function _now() { return Utilities.formatDate(new Date(), TZ, TS_FMT); }

  function _load(execId) {
    var cache = CacheService.getUserCache();
    var raw = cache.get(_key(execId));
    if (!raw) return [];
    try {
      var arr = JSON.parse(raw);
      return Array.isArray(arr) ? arr : [];
    } catch (e) {
      return [];
    }
  }

  function _save(execId, arr) {
    var buf = (arr || []).slice(-MAX_LINES);
    CacheService.getUserCache().put(_key(execId), JSON.stringify(buf), TTL_SECONDS);
  }

  function push(execId, text, level) {
    var arr = _load(execId);
    arr.push({ ts: _now(), level: String(level || 'info'), text: String(text) });
    _save(execId, arr);
    return true;
  }

  function fetchLast(execId) {
    var arr = _load(execId);
    var line = arr.length ? arr[arr.length - 1] : null;
    return { line: line, count: arr.length };
  }

  function fetchAll(execId) {
    var arr = _load(execId);
    return { lines: arr, count: arr.length };
  }

  function clear(execId) {
    CacheService.getUserCache().remove(_key(execId));
    return true;
  }

  // ------------------------
  // Wrappers padronizados
  // ------------------------
  function iniciando(execId, processoOuMsg) {
    return push(execId, '[INICIANDO] ' + processoOuMsg, 'info');
  }
  function andamento(execId, msg) {
    return push(execId, '[EM ANDAMENTO] ' + msg, 'info');
  }
  function ok(execId, msg) {
    return push(execId, '[OK] ' + msg, 'ok');
  }
  function aviso(execId, msg) {
    return push(execId, '[AVISO] ' + msg, 'warn');
  }
  function erro(execId, msg) {
    return push(execId, '[ERRO] ' + msg, 'error');
  }
  function erroFatal(execId, msg) {
    return push(execId, '[ERRO FATAL] ' + msg, 'error');
  }
  function final(execId, msg) {
    // Destaque final (classe heurística no front também marcará como "status-final")
    return push(execId, '✅ ' + msg, 'final');
  }

  return {
    push: push,
    fetchLast: fetchLast,
    fetchAll: fetchAll,
    clear: clear,
    iniciando: iniciando,
    andamento: andamento,
    ok: ok,
    aviso: aviso,
    erro: erro,
    erroFatal: erroFatal,
    final: final
  };
})();

// ---- Exposição segura para o HTMLService (frontend chama via google.script.run)
function RT_fetchLast(execId){ return RT.fetchLast(execId); }
function RT_fetchAll(execId){ return RT.fetchAll(execId); }
function RT_clear(execId){ return RT.clear(execId); }
